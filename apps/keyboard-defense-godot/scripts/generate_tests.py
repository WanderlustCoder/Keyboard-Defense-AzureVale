#!/usr/bin/env python3
"""
Test Scaffolding Generator

Generates test function stubs for GDScript features.
Can analyze existing files or generate from templates.

Usage:
    python scripts/generate_tests.py --file sim/new_feature.gd
    python scripts/generate_tests.py --intent build_tower
    python scripts/generate_tests.py --enemy dragon
    python scripts/generate_tests.py --command explore
"""

import argparse
import re
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional

# Project paths
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent


# ============================================================================
# TEST TEMPLATES
# ============================================================================

HEADER_TEMPLATE = """
# ============================================================================
# AUTO-GENERATED TEST STUBS
# Generated by: scripts/generate_tests.py
# Add these to: tests/run_tests.gd
# ============================================================================
"""

FUNCTION_TEST_TEMPLATE = """
func test_{name}_exists() -> void:
\t# Verify the function exists and is callable
\tassert({class_name}.has_method("{name}"), "{name} should exist")
\t_pass("test_{name}_exists")


func test_{name}_basic() -> void:
\t# Test basic functionality
\tvar state := GameState.new()
\t# TODO: Set up state
\t
\t# TODO: Call the function
\t# var result = {class_name}.{name}(state, ...)
\t
\t# TODO: Assert expected results
\t# assert(result == expected, "Should return expected value")
\t_pass("test_{name}_basic")
"""

INTENT_TEST_TEMPLATE = """
func test_{intent_name}_parses() -> void:
\tvar result := CommandParser.parse("{command}")
\tassert(result["ok"] == true, "Should parse successfully")
\tassert(result["intent"]["kind"] == "{intent_name}", "Intent kind should match")
\t_pass("test_{intent_name}_parses")


func test_{intent_name}_requires_phase() -> void:
\tvar state := GameState.new()
\tstate.phase = "night"  # Wrong phase
\tvar intent := SimIntents.make("{intent_name}")
\tvar result := IntentApplier.apply(state, intent)
\t# TODO: Adjust expected phase
\tassert("day" in str(result["events"]).to_lower() or result["state"].phase == "night",
\t\t"Should require correct phase")
\t_pass("test_{intent_name}_requires_phase")


func test_{intent_name}_modifies_state() -> void:
\tvar state := GameState.new()
\tstate.phase = "day"
\tstate.ap = 10
\t# TODO: Set up required state
\t
\tvar intent := SimIntents.make("{intent_name}", {params})
\tvar result := IntentApplier.apply(state, intent)
\t
\t# TODO: Assert state was modified correctly
\t# assert(result["state"].some_value == expected, "Should modify state")
\t_pass("test_{intent_name}_modifies_state")


func test_{intent_name}_costs_ap() -> void:
\tvar state := GameState.new()
\tstate.phase = "day"
\tstate.ap = 5
\t# TODO: Set up required state
\t
\tvar intent := SimIntents.make("{intent_name}", {params})
\tvar before_ap := state.ap
\tvar result := IntentApplier.apply(state, intent)
\t
\t# TODO: Adjust expected AP cost
\tassert(result["state"].ap < before_ap, "Should cost AP")
\t_pass("test_{intent_name}_costs_ap")
"""

ENEMY_TEST_TEMPLATE = """
func test_{enemy_name}_in_kinds() -> void:
\tassert("{enemy_name}" in SimEnemies.ENEMY_KINDS, "{enemy_name} should be in ENEMY_KINDS")
\t_pass("test_{enemy_name}_in_kinds")


func test_{enemy_name}_has_valid_stats() -> void:
\tvar kind: Dictionary = SimEnemies.ENEMY_KINDS.get("{enemy_name}", {{}})
\tassert(kind.has("speed"), "Should have speed")
\tassert(kind.has("glyph"), "Should have glyph")
\tassert(int(kind.get("speed", 0)) >= 1, "Speed should be at least 1")
\t_pass("test_{enemy_name}_has_valid_stats")


func test_{enemy_name}_spawns() -> void:
\tvar state := GameState.new()
\tstate.day = 1
\tstate.map_w = 10
\tstate.map_h = 10
\t
\t# TODO: Use actual spawn function if different
\tvar enemy := {{"kind": "{enemy_name}", "hp": 10, "x": 0, "y": 0, "word": "test"}}
\tstate.enemies.append(enemy)
\t
\tassert(state.enemies.size() == 1, "Should have one enemy")
\tassert(state.enemies[0]["kind"] == "{enemy_name}", "Kind should match")
\t_pass("test_{enemy_name}_spawns")


func test_{enemy_name}_takes_damage() -> void:
\tvar state := GameState.new()
\tvar enemy := {{"kind": "{enemy_name}", "hp": 10, "x": 0, "y": 0, "word": "test"}}
\tstate.enemies.append(enemy)
\t
\t# Simulate damage
\tstate.enemies[0]["hp"] -= 5
\t
\tassert(state.enemies[0]["hp"] == 5, "HP should decrease")
\t_pass("test_{enemy_name}_takes_damage")
"""

BUILDING_TEST_TEMPLATE = """
func test_{building_name}_in_types() -> void:
\t# TODO: Adjust to actual building registry
\tassert("{building_name}" in GameState.BUILDING_KEYS or true, "{building_name} should be registered")
\t_pass("test_{building_name}_in_types")


func test_{building_name}_costs() -> void:
\t# TODO: Get actual cost from balance or data
\tvar cost := {{"wood": 5, "stone": 3}}
\tassert(cost.has("wood") or cost.has("stone") or cost.has("food"),
\t\t"Should have resource cost")
\t_pass("test_{building_name}_costs")


func test_{building_name}_can_build() -> void:
\tvar state := GameState.new()
\tstate.phase = "day"
\tstate.ap = 10
\tstate.resources = {{"wood": 100, "stone": 100, "food": 100}}
\tstate.map_w = 10
\tstate.map_h = 10
\tstate.terrain = []
\tfor i in range(100):
\t\tstate.terrain.append(".")
\t
\t# TODO: Test build command
\t# var intent := SimIntents.make("build", {{"type": "{building_name}", "x": 5, "y": 5}})
\t# var result := IntentApplier.apply(state, intent)
\t# assert(result["ok"], "Should be able to build")
\t_pass("test_{building_name}_can_build")
"""

LESSON_TEST_TEMPLATE = """
func test_{lesson_id}_exists() -> void:
\tvar lessons := SimLessons.load_all()
\tvar found := false
\tfor lesson in lessons:
\t\tif lesson.get("id", "") == "{lesson_id}":
\t\t\tfound = true
\t\t\tbreak
\tassert(found, "{lesson_id} should exist in lessons")
\t_pass("test_{lesson_id}_exists")


func test_{lesson_id}_has_required_fields() -> void:
\tvar lessons := SimLessons.load_all()
\tvar lesson: Dictionary = {{}}
\tfor l in lessons:
\t\tif l.get("id", "") == "{lesson_id}":
\t\t\tlesson = l
\t\t\tbreak
\t
\tassert(lesson.has("name"), "Should have name")
\tassert(lesson.has("mode"), "Should have mode")
\t_pass("test_{lesson_id}_has_required_fields")


func test_{lesson_id}_generates_words() -> void:
\tvar state := GameState.new()
\tstate.lesson_id = "{lesson_id}"
\t
\t# TODO: Test word generation
\t# var word := SimWords.generate_for_enemy(state, "scout")
\t# assert(word.length() > 0, "Should generate non-empty word")
\t_pass("test_{lesson_id}_generates_words")
"""


# ============================================================================
# FILE ANALYSIS
# ============================================================================

def analyze_gdscript(filepath: Path) -> Dict[str, Any]:
    """Analyze a GDScript file and extract testable elements."""
    if not filepath.exists():
        return {"error": f"File not found: {filepath}"}

    content = filepath.read_text(encoding="utf-8")

    # Extract class name
    class_match = re.search(r"class_name\s+(\w+)", content)
    class_name = class_match.group(1) if class_match else filepath.stem

    # Extract static functions
    static_funcs = re.findall(r"static\s+func\s+(\w+)\s*\(([^)]*)\)", content)

    # Extract regular functions
    funcs = re.findall(r"^func\s+(\w+)\s*\(([^)]*)\)", content, re.MULTILINE)

    # Extract constants
    constants = re.findall(r"const\s+(\w+)\s*[=:]", content)

    return {
        "class_name": class_name,
        "static_functions": [(name, params) for name, params in static_funcs],
        "functions": [(name, params) for name, params in funcs if not name.startswith("_")],
        "constants": constants,
        "filepath": str(filepath),
    }


def generate_tests_for_file(filepath: Path) -> str:
    """Generate test stubs for a GDScript file."""
    analysis = analyze_gdscript(filepath)

    if "error" in analysis:
        return f"# Error: {analysis['error']}"

    lines = [HEADER_TEMPLATE]
    lines.append(f"# Tests for: {analysis['filepath']}")
    lines.append(f"# Class: {analysis['class_name']}")
    lines.append("")

    # Generate tests for static functions
    for func_name, params in analysis["static_functions"]:
        if func_name.startswith("_"):
            continue  # Skip private functions

        lines.append(FUNCTION_TEST_TEMPLATE.format(
            name=func_name,
            class_name=analysis["class_name"]
        ))

    # Generate tests for public functions
    for func_name, params in analysis["functions"]:
        lines.append(FUNCTION_TEST_TEMPLATE.format(
            name=func_name,
            class_name=analysis["class_name"]
        ))

    return "\n".join(lines)


# ============================================================================
# TEMPLATE-BASED GENERATION
# ============================================================================

def generate_intent_tests(intent_name: str, command: str = None, params: str = "{}") -> str:
    """Generate test stubs for an intent/command."""
    if command is None:
        command = intent_name

    return HEADER_TEMPLATE + INTENT_TEST_TEMPLATE.format(
        intent_name=intent_name,
        command=command,
        params=params
    )


def generate_enemy_tests(enemy_name: str) -> str:
    """Generate test stubs for an enemy type."""
    return HEADER_TEMPLATE + ENEMY_TEST_TEMPLATE.format(
        enemy_name=enemy_name
    )


def generate_building_tests(building_name: str) -> str:
    """Generate test stubs for a building type."""
    return HEADER_TEMPLATE + BUILDING_TEST_TEMPLATE.format(
        building_name=building_name
    )


def generate_lesson_tests(lesson_id: str) -> str:
    """Generate test stubs for a lesson."""
    return HEADER_TEMPLATE + LESSON_TEST_TEMPLATE.format(
        lesson_id=lesson_id
    )


# ============================================================================
# MAIN
# ============================================================================

def main():
    parser = argparse.ArgumentParser(description="Generate test stubs for GDScript features")
    parser.add_argument("--file", "-f", type=str,
                        help="Analyze GDScript file and generate tests")
    parser.add_argument("--intent", "-i", type=str,
                        help="Generate tests for an intent/command")
    parser.add_argument("--command", "-c", type=str,
                        help="Command string for intent (default: same as intent)")
    parser.add_argument("--enemy", "-e", type=str,
                        help="Generate tests for an enemy type")
    parser.add_argument("--building", "-b", type=str,
                        help="Generate tests for a building type")
    parser.add_argument("--lesson", "-l", type=str,
                        help="Generate tests for a lesson")
    parser.add_argument("--output", "-o", type=str,
                        help="Output file (default: stdout)")
    parser.add_argument("--append", "-a", action="store_true",
                        help="Append to tests/run_tests.gd")

    args = parser.parse_args()

    output = ""

    if args.file:
        filepath = PROJECT_ROOT / args.file
        if not filepath.exists():
            filepath = Path(args.file)
        output = generate_tests_for_file(filepath)

    elif args.intent:
        output = generate_intent_tests(args.intent, args.command)

    elif args.enemy:
        output = generate_enemy_tests(args.enemy)

    elif args.building:
        output = generate_building_tests(args.building)

    elif args.lesson:
        output = generate_lesson_tests(args.lesson)

    else:
        print("Error: Specify one of --file, --intent, --enemy, --building, or --lesson")
        parser.print_help()
        sys.exit(1)

    # Output
    if args.append:
        tests_file = PROJECT_ROOT / "tests" / "run_tests.gd"
        if tests_file.exists():
            with open(tests_file, "a", encoding="utf-8") as f:
                f.write("\n\n")
                f.write(output)
            print(f"Appended to {tests_file}")
        else:
            print(f"Error: {tests_file} not found")
            sys.exit(1)
    elif args.output:
        output_path = Path(args.output)
        output_path.write_text(output, encoding="utf-8")
        print(f"Written to {output_path}")
    else:
        print(output)


if __name__ == "__main__":
    main()
